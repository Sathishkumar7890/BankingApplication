package flow.subflow.GeneralMsg;

import java.util.Collection;

import org.json.JSONArray;
import org.json.JSONObject;

import com.HostJar.Flow.IVRFlow;
import com.avaya.sce.runtime.Goto;
import com.avaya.sce.runtime.tracking.TraceInfo;
import com.avaya.sce.runtimecommon.ITraceInfo;
import com.avaya.sce.runtimecommon.SCESession;

import flow.IProjectVariables;


/**
 * A basic servlet which allows a user to define their code, generate
 * any output, and to select where to transition to next.
 * Last generated by Orchestration Designer at: 2026-FEB-02  06:30:46 PM
 */
public class FETCH_Node extends com.avaya.sce.runtime.BasicServlet {

	//{{START:CLASS:FIELDS
	//}}END:CLASS:FIELDS

	/**
	 * Default constructor
	 * Last generated by Orchestration Designer at: 2026-FEB-02  06:30:46 PM
	 */
	public FETCH_Node() {
		//{{START:CLASS:CONSTRUCTOR
		super();
		//}}END:CLASS:CONSTRUCTOR
	}

	/**
	 * This method allows for custom integration with other Java components.
	 * You may use Java for sophisticated logic or to integrate with custom
	 * connectors (i.e. JMS, custom web services, sockets, XML, JAXB, etc.)
	 *
	 * Any custom code added here should work as efficiently as possible to prevent delays.
	 * It's important to design your callflow so that the voice browser (Experienve Portal/IR)
	 * is not waiting too long for a response as this can lead to a poor caller experience.
	 * Additionally, if the response to the client voice browser exceeds the configured
	 * timeout, the platform may throw an "error.badfetch". 
	 *
	 * Using this method, you have access to all session variables through the 
	 * SCESession object.
	 *
	 * The code generator will *** NOT *** overwrite this method in the future.
	 * Last generated by Orchestration Designer at: 2026-FEB-02  06:30:46 PM
	 */
	public void servletImplementation(com.avaya.sce.runtimecommon.SCESession mySession) {

		// TODO: Add your code here!

	}
	/**
	 * Builds the list of branches that are defined for this servlet object.
	 * This list is built automatically by defining Goto nodes in the call flow editor.
	 * It is the programmer's responsibilty to provide at least one enabled Goto.<BR>
	 *
	 * The user should override updateBranches() to determine which Goto that the
	 * framework will activate.  If there is not at least one enabled Goto item, 
	 * the framework will throw a runtime exception.<BR>
	 *
	 * This method is generated automatically and changes to it may
	 * be overwritten next time code is generated.  To modify the list
	 * of branches for the flow item, override:
	 *     <code>updateBranches(Collection branches, SCESession mySession)</code>
	 *
	 * @return a Collection of <code>com.avaya.sce.runtime.Goto</code>
	 * objects that will be evaluated at runtime.  If there are no gotos
	 * defined in the Servlet node, then this returns null.
	 * Last generated by Orchestration Designer at: 2026-FEB-20  11:52:55 AM
	 */
	public java.util.Collection getBranches(com.avaya.sce.runtimecommon.SCESession mySession) {
		java.util.List list = null;
		com.avaya.sce.runtime.Goto aGoto = null;
		list = new java.util.ArrayList(1);

		aGoto = new com.avaya.sce.runtime.Goto("GeneralMsg-IDENTIFICATION", 0, true, "Default");
		list.add(aGoto);

		return list;
	}
	
//	@Override
//	public void requestBegin(SCESession mySession) {
//		// TODO Auto-generated method stub
//		super.requestBegin(mySession);
//		TraceInfo.trace(ITraceInfo.TRACE_LEVEL_INFO,"NRMN AUTHENTICATE FLOW",mySession);
//		String NextNodeDescription = mySession.getVariableField(IProjectVariables.NODE_DETAILS,IProjectVariables.NODE_DETAILS_FIELD_FETCH_NEXTNODE).getStringValue();
//		IVRFlow ivrFlow = new IVRFlow();
//		 
//		TraceInfo.trace(ITraceInfo.TRACE_LEVEL_INFO,"NRMN NEXT NODE***** : " + NextNodeDescription,mySession);
//		
//		JSONObject menuDetails = IVRFlow.getNodeByDescription(NextNodeDescription);
//		 
//		TraceInfo.trace(ITraceInfo.TRACE_LEVEL_INFO,
//		        "Node Details : " + menuDetails.toString(),
//		        mySession);
//		
//
//		
//		JSONArray menuPrompts = menuDetails.getJSONArray("menuPrompts");
//		 
//		for (int i = 0; i < menuPrompts.length(); i++) {
//		    String prompt = menuPrompts.getString(i);
//
//		    TraceInfo.trace(ITraceInfo.TRACE_LEVEL_INFO,"NRMN IDENTIFICATION FLOW: " + prompt,
//		            mySession);
//			mySession.getVariableField(IProjectVariables.PROMPT_URL,IProjectVariables.PROMPT_URL_FIELD_PROMPT_FULL_URL).setValue(prompt);
//			
//			
//	   boolean RMN_Flag = mySession.getVariableField(IProjectVariables.RMNIDENTIFICATION,IProjectVariables.RMNIDENTIFICATION_FIELD_RMNFLAG).getBooleanValue();
//	   
//	   TraceInfo.trace(ITraceInfo.TRACE_LEVEL_INFO,"RMN_Flag : " + RMN_Flag,
//	            mySession);
//		}
//	}
//	
////	@Override
////	public void updateBranches(Collection branches, SCESession mySession) {
//// 
////    	Goto aGoto = null;
////		boolean error = false;
////
////		try {
////			String NextNodeDescription = mySession.getVariableField(IProjectVariables.NODE_DETAILS,IProjectVariables.NODE_DETAILS_FIELD_FETCH_NEXTNODE).getStringValue();
////		    TraceInfo.trace(ITraceInfo.TRACE_LEVEL_INFO,
////		            "Next Node Session : " + NextNodeDescription,
////		            mySession);
////		    
////			IVRFlow IVR = new IVRFlow();
////			JSONObject menuDetails = IVRFlow.getNodeByDescription(NextNodeDescription);
//// 
////			TraceInfo.trace(ITraceInfo.TRACE_LEVEL_INFO,
////			        "Node Details : " + menuDetails.toString(),
////			        mySession);
////			
////			
////			    JSONArray NOINPUT = menuDetails.getJSONArray("noInputPrompt");
////			    JSONArray NOMATCH = menuDetails.getJSONArray("noMatchPrompt");
////			    JSONArray MAX = menuDetails.getJSONArray("maxTriesPrompt");
////			   
////			   
////			    mySession.getVariableField(IProjectVariables.RETRY,IProjectVariables.RETRY_FIELD_NOINPUT).setValue(NOINPUT);
////			    mySession.getVariableField(IProjectVariables.RETRY,IProjectVariables.RETRY_FIELD_NOMATCH).setValue(NOMATCH);
////			    mySession.getVariableField(IProjectVariables.RETRY,IProjectVariables.RETRY_FIELD_MAX).setValue(MAX);
////			    
////			    
////			    TraceInfo.trace(ITraceInfo.TRACE_LEVEL_INFO, "NOINPUT " + NOINPUT,mySession);
////			    TraceInfo.trace(ITraceInfo.TRACE_LEVEL_INFO, "NOMATCH " + NOMATCH,mySession);
////			    TraceInfo.trace(ITraceInfo.TRACE_LEVEL_INFO, "MAX" + MAX,mySession);
////			    
////// 
//////			JSONArray nextNodes = menuDetails.getJSONArray("nextNode");
//////			for (int i = 0; i < nextNodes.length(); i++) {
//////			    String nextNode = nextNodes.getString(i);
////// 
//////			    TraceInfo.trace(ITraceInfo.TRACE_LEVEL_INFO,
//////			            "NRMN**** Next Node : " + nextNode,
//////			            mySession);
//////			    mySession.getVariableField(IProjectVariables.NODE_DETAILS,IProjectVariables.NODE_DETAILS_FIELD_FETCH_NEXTNODE).setValue(nextNode);
//////			}
//// 
////			//String nodeType = menuDetails.getString("nodeType");
////
////			//JSONArray menuPrompts = menuDetails.getJSONArray("menuPrompts");
//// 
//////			for (int i = 0; i < menuPrompts.length(); i++) {
//////			    String prompt = menuPrompts.getString(i);
////// 
//////			    TraceInfo.trace(ITraceInfo.TRACE_LEVEL_INFO,
//////			            "Prompt : " + prompt,
//////			            mySession);
//////				mySession.getVariableField(IProjectVariables.PROMPT_URL,IProjectVariables.PROMPT_URL_FIELD_PROMPT_FULL_URL).setValue(prompt);
//////			}
//////			TraceInfo.trace(ITraceInfo.TRACE_LEVEL_INFO,
//////			        "Node Type : " + nodeType,
//////			        mySession);
////			//mySession.getVariableField(IProjectVariables.NODE_DETAILS,IProjectVariables.NODE_DETAILS_FIELD_NEXT_NODE).setValue(nodeType);
////			String SessionNextNode = mySession.getVariableField(IProjectVariables.NODE_DETAILS,IProjectVariables.NODE_DETAILS_FIELD_FETCH_NEXTNODE).getStringValue();
////			
////			String NewNextNode = mySession.getVariableField(IProjectVariables.NODE_DETAILS,IProjectVariables.NODE_DETAILS_FIELD_FETCH_NEXTNODE).getStringValue();
////			
////			
////			TraceInfo.trace(ITraceInfo.TRACE_LEVEL_INFO,"SessionNextNode****** : "+SessionNextNode, mySession);
////			TraceInfo.trace(ITraceInfo.TRACE_LEVEL_INFO,"Session Next Node : "+SessionNextNode, mySession);
//// 
////				aGoto = new Goto("IDENTIFICATION", 0);
////				branches.clear();
////				branches.add(aGoto);
//// 
////		} catch(Exception e) {
//// 
////			TraceInfo.trace(ITraceInfo.TRACE_LEVEL_ERROR,"Error on Getting Next Node", mySession);
////			mySession.getVariableField("Error").setValue(true);
////			aGoto = new Goto("SetTechDiffPrompt", 0);
////			branches.clear();
////			branches.add(aGoto);
//// 
////		}
//// 
////		super.updateBranches(branches, mySession);
////	}
//}
}
